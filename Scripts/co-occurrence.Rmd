---
title: "Networks"
author: "Beatrice Cornu Hewitt" 
date: "`r Sys.time()`"
---

SPIEC-EASI made for microbiome co-occurrence networks
# Libraries 
```{r}
# Install required packages
# Load libraries
library(phyloseq)
library(dplyr)
library(devtools)
library(pulsar)
library(MASS)
library(igraph)
library(ggplot2)
library(purrr)
library(patchwork)
library(poweRlaw)
library(data.table)
library(RColorBrewer)
library(ggraph)

# install_github("zdk123/SpiecEasi")
library(SpiecEasi)
#install_github("vallenderlab/MicrobiomeR") # Install the package
library(microbiomer)
```

# Functions 
```{r}
# Functions for network creation
get_edge_weights_slr <- function(se) {
  se.icov <- se$select$est$icov[[getOptInd(se)]]
  se.cov <- solve(se.icov)
  return(list(se.icov = se.icov, se.cov = se.cov))
  # https://github.com/zdk123/SpiecEasi/issues/198
}


get_igraph_edges <- function(se) {
  se.cov <- get_edge_weights_slr(se)$se.cov
  se.weighted <- graph.adjacency(se.cov * getRefit(se), mode = "undirected", weighted = TRUE, diag = FALSE)
  # https://github.com/zdk123/SpiecEasi/issues/198
  return(se.weighted)
}

create_ig_df <- function(se_slr, ps_filt) {
  ig_slr_fae_df <- get.data.frame(get_igraph_edges(se_slr), what = c("edges")) %>% #se_slr_fae
    mutate(from = taxa_names(ps_filt)[from],
           to = taxa_names(ps_filt)[to]) 
  
}

prep_ig <- function(se_slr, ps_filt, ig_df) {
  
  get_list_of_columns <- function(df) { 
    list_cols <- map(seq_len(ncol(df)), ~df[,.x]) 
    names(list_cols) <- colnames(df)
    return(list_cols)
  }
ig_slr <- adj2igraph(getRefit(se_slr),  
                       vertex.attr = get_list_of_columns(tax_table(ps_filt) %>% as(., "matrix"))) %>%
    set_edge_attr(name = "edge_width", value = abs(ig_df$weight)) %>% 
    set_edge_attr(name = "sign", value = if_else(ig_df$weight < 0, "neg", "pos")) 
  return(ig_slr)
}


plot_ig <- function(ig) {
  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>% 
    ggraph(layout =  "kk") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +  # Color edges based on sign
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +  # Set colors for neg and pos edges
    geom_node_point(shape = 20, size = 12, aes(colour = Family), alpha = 0.4) +
    geom_node_text(aes(label = ASV), repel = TRUE, size = 4) +
    theme_minimal() + 
    theme(
      panel.background = element_rect(fill = "white", color = NA), # White panel background
      plot.background = element_rect(fill = "white", color = NA),  # White plot background
      axis.line = element_blank(),      # Removes x and y axis lines
      axis.ticks = element_blank(),     # Removes axis ticks
      axis.text = element_blank(),      # Removes axis text
      axis.title = element_blank(),     # Removes axis titles
      legend.text = element_text(size = 10),  # Make legend text smaller
      legend.title = element_text(size = 10),  # Make legend title smaller
      legend.spacing = unit(0.5, "lines"),  # Reduce spacing between legend items
      legend.position = "right"  # Keep legend position on the right
    ) +
    guides(
      colour = guide_legend(override.aes = list(size = 4)),  # Adjust legend size separately
      edge_width = "none"  # Remove edge width from the legend
    )
}


plot_ig_genus <- function(ig) {
  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>% 
    ggraph(layout =  "kk") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +  # Color edges based on sign
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +  # Set colors for neg and pos edges
    geom_node_point(shape = 20, size = 12, aes(colour = Family), alpha = 0.4) +
    geom_node_text(aes(label = Genus), repel = TRUE, size = 4) +
    theme_minimal() + 
    theme(
      panel.background = element_rect(fill = "white", color = NA), # White panel background
      plot.background = element_rect(fill = "white", color = NA),  # White plot background
      axis.line = element_blank(),      # Removes x and y axis lines
      axis.ticks = element_blank(),     # Removes axis ticks
      axis.text = element_blank(),      # Removes axis text
      axis.title = element_blank(),     # Removes axis titles
      legend.text = element_text(size = 10),  # Make legend text smaller
      legend.title = element_text(size = 10),  # Make legend title smaller
      legend.spacing = unit(0.5, "lines"),  # Reduce spacing between legend items
      legend.position = "right"  # Keep legend position on the right
    ) +
    guides(
      colour = guide_legend(override.aes = list(size = 4)),  # Adjust legend size separately
      edge_width = "none"  # Remove edge width from the legend
    )
}




plot_ig_nodal_size <- function(ig) {
  # Extract unique families and define colors
  unique_family <- unique(V(ig)$Family)  # Get unique families
  num_colors <- length(unique_family)  # Count families
  my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(num_colors)  # Generate a color palette

  # Calculate degree and add it as a vertex attribute
  V(ig)$degree <- igraph::degree(ig)  # Calculate degree for each node

  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>%  # Remove nodes with degree 0
    ggraph(layout = "kk") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +  # Set edge colors
    geom_node_point(shape = 20, aes(colour = Family, size = degree), alpha = 0.8) +  # Map size to degree
    scale_colour_manual(values = setNames(my_colors, unique_family)) +  # Assign colors to families
    scale_size_continuous(range = c(5, 20), guide = "none") +  # Adjust size range for nodes
    geom_node_text(aes(label = ASV), repel = TRUE, size = 3) +  # Add node labels
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      legend.text = element_text(size = 8),  # Adjust legend text size
      legend.title = element_text(size = 10),  # Adjust legend title size
      legend.spacing = unit(0.5, "lines"),  # Adjust spacing in the legend
      legend.key.size = unit(0.5, "lines"),  # Adjust key size in the legend
      legend.position = "right"
    ) +
    guides(
      colour = guide_legend(
        override.aes = list(size = 4)  # Adjust legend symbol size
      ),
      edge_width = "none"  # Hide edge width in the legend
    )
}


plot_ig_betweeness_centrality <- function(ig) {
  # Extract unique families and define colors
  unique_family <- unique(V(ig)$Family)  # Get unique families
  num_colors <- length(unique_family)  # Count families
  my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(num_colors)  # Generate a color palette

  # Calculate betweeness centrality and add it as a vertex attribute
  V(ig)$betweenness <- igraph::betweenness(ig, normalized = TRUE)  # Calculate normalized betweenness

  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>%  # Remove nodes with degree 0
    ggraph(layout = "kk") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +  # Set edge colors
    geom_node_point(shape = 20, aes(colour = Family, size = betweenness), alpha = 0.8) +  # Map size to betweenness
    scale_colour_manual(values = setNames(my_colors, unique_family)) +  # Assign colors to families
    scale_size_continuous(range = c(5, 20), guide = "none") +  # Adjust size range for nodes
    geom_node_text(aes(label = ASV), repel = TRUE, size = 3) +  # Add node labels
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      legend.text = element_text(size = 8),  # Adjust legend text size
      legend.title = element_text(size = 10),  # Adjust legend title size
      legend.spacing = unit(0.5, "lines"),  # Adjust spacing in the legend
      legend.key.size = unit(0.5, "lines"),  # Adjust key size in the legend
      legend.position = "right"
    ) +
    guides(
      colour = guide_legend(
        override.aes = list(size = 4)  # Adjust legend symbol size
      ),
      edge_width = "none"  # Hide edge width in the legend
    )
}


plot_ig_nodal_size_bold <- function(ig) {
  # Extract unique families and define colors
  unique_family <- unique(V(ig)$Family)  # Get unique families
  num_colors <- length(unique_family)  # Count families
  my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(num_colors)  # Generate a color palette

  # Define ASVs to be bolded
  bold_asvs <- c("Staphylococcus_256", "Staphylococcaceae_295", "Spingomonas_175", "Corynebacterium_stationis_251")

  # Calculate degree and add it as a vertex attribute
  V(ig)$degree <- igraph::degree(ig)  # Calculate degree for each node

  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>%  # Remove nodes with degree 0
    ggraph(layout = "kk") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +  # Set edge colors
    geom_node_point(shape = 20, aes(colour = Family, size = degree), alpha = 0.8) +  # Map size to degree
    scale_colour_manual(values = setNames(my_colors, unique_family)) +  # Assign colors to families
    scale_size_continuous(range = c(5, 20), guide = "none") +  # Adjust size range for nodes
    geom_node_text(aes(label = ASV, fontface = ifelse(ASV %in% bold_asvs, "bold", "plain")), 
                   repel = TRUE, size = 3) +  # Add node labels with conditional bolding
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid = element_blank(),  # Remove all grid lines (guidelines)
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      legend.text = element_text(size = 8),  # Adjust legend text size
      legend.title = element_text(size = 10),  # Adjust legend title size
      legend.spacing = unit(0.5, "lines"),  # Adjust spacing in the legend
      legend.key.size = unit(0.5, "lines"),  # Adjust key size in the legend
      legend.position = "right"
    ) +
    guides(
      colour = guide_legend(
        override.aes = list(size = 4)  # Adjust legend symbol size
      ),
      edge_width = "none"  # Hide edge width in the legend
    )
}



```
# NP vs OP networks
## CP (all) NP
```{r}
# Data for all
ps <- readRDS("../Output/Phyloseq/ps_complete_new_metadata_RFpreds.rds")

# Filter for CP only 
ps_cp_only_np <- ps %>%
  subset_samples(niche == "NP" & population == "CP") # 836 samples

# Prune zero sum taxa and apply filter
ps_cp_only_np_filt <- ps_cp_only_np %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 836 * 0.03, abund = 0.01) # 28 ASVs remaining

# Extract the abundance table (ASV table)
otu_matrix_cp_only_np <- as(otu_table(ps_cp_only_np_filt), "matrix")
otu_matrix_cp_only_np <- t(otu_matrix_cp_only_np)
# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads. 

se_cp_only_np_slr <- spiec.easi(otu_matrix_cp_only_np, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# r defines the rank (size) of the low-rank component of the algorithm - i.e. the effects of latent variables, i.e. the algorithm will estimate up to 10 latent variables - larger r means more complex hidden factors
# lambda.min.ratio = 1e-2: Determines the range of regularization strengths (lambda) to test. 1e-2 means the smallest lambda tested will be 1% of the largest lambda. 
# nlambda = 20: Specifies the number of regularization parameters (lambda) to test. A higher number of lambda values results in finer tuning of the network sparsity.
# pulsar.params = list(rep.num = 20): Configures the Pulsar framework, which performs stability selection by resampling the data.

# Prepare for network plot
ig_slr_cp_only_np_df <- create_ig_df(se_cp_only_np_slr, ps_cp_only_np_filt)
ig_slr_cp_only_np_df %>% arrange(-weight)

 # Prepare for igraph
ig_slr_cp_only_np <- prep_ig(se_cp_only_np_slr, ps_cp_only_np_filt, ig_slr_cp_only_np_df)

igraph_cp_only_np <- plot_ig(ig_slr_cp_only_np) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_np
ggsave("../Output/Networks/igraph_cp_all_np.svg", igraph_cp_only_np, width = 8, height = 5.5)
```

## CP (all) OP
```{r}
# Data for all
ps <- readRDS("../Output/Phyloseq/ps_complete_new_metadata_RFpreds.rds")

# Filter for CP only 
ps_cp_only_op <- ps %>%
  subset_samples(niche == "OP" & population == "CP") # 978  samples

# Prune zero sum taxa and apply filter
ps_cp_only_op_filt <- ps_cp_only_op %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 978 * 0.03, abund = 0.02) # 43 ASVs remaining

# Extract the abundance table (ASV table)
otu_matrix_cp_only_op <- as(otu_table(ps_cp_only_op_filt), "matrix")
otu_matrix_cp_only_op <- t(otu_matrix_cp_only_op)

# Spiec-easi 
se_cp_only_op_slr <- spiec.easi(otu_matrix_cp_only_op, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_op_df <- create_ig_df(se_cp_only_op_slr, ps_cp_only_op_filt)
ig_slr_cp_only_op_df %>% arrange(-weight)

 # Prepare for igraph
ig_slr_cp_only_op <- prep_ig(se_cp_only_op_slr, ps_cp_only_op_filt, ig_slr_cp_only_op_df)

igraph_cp_only_op <- plot_ig(ig_slr_cp_only_op) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_op
ggsave("../Output/Networks/igraph_cp_all_op.svg", igraph_cp_only_op, width = 8, height = 5.5)
```

### Comparison NP vs OP 
```{r}
# COmpare:
## Degree distribution
## Clustering coefficient
## Average path length
## Network density

# For NP network (igraph_cp_np)
degree_np <- degree(ig_slr_cp_np)
clustering_np <- transitivity(ig_slr_cp_np)
avg_path_length_np <- average.path.length(ig_slr_cp_np)
network_density_np <- edge_density(ig_slr_cp_np)

# For OP network (igraph_cp_op)
degree_op <- degree(ig_slr_cp_op)
clustering_op <- transitivity(ig_slr_cp_op)
avg_path_length_op <- average.path.length(ig_slr_cp_op)
network_density_op <- edge_density(ig_slr_cp_op)

# Compare the networks
comparison_cp_npvsop <- data.frame(
  Metric = c("Average Degree", "Clustering Coefficient", "Avg Path Length", "Density"),
  NP = c(mean(degree_np), mean(clustering_np), avg_path_length_np, network_density_np),
  OP = c(mean(degree_op), mean(clustering_op), avg_path_length_op, network_density_op)
)

print(comparison_cp_npvsop)


##### Compare community structure
# Using Louvain community detection
community_np <- cluster_louvain(ig_slr_cp_np)
community_op <- cluster_louvain(ig_slr_cp_op)

# Get the modularity score to assess how well the network is divided into communities
modularity_np <- modularity(community_np)
modularity_op <- modularity(community_op)

# Compare the modularity
print(modularity_np)
print(modularity_op)

```
# Filtering of data based on prevalence/abundance 
## Farmers vs residents
### NP 
```{r}
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for NP only 
ps_cp_gf_np <- ps_cp_gf %>%
  subset_samples(niche == "NP") # 237 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_np_filt <- ps_cp_gf_np %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 237 * 0.03, abund = 0.01) # 33 ASVs remaining

### GF ###
# Subset phyloseq for GF
ps_gf_only_filt <- ps_cp_gf_np_filt %>%
  subset_samples(population == "GF") # 77 samples

str(ps_gf_only_filt@otu_table)

# Extract the abundance table (ASV table)
asv_matrix_gf_only_np <- as(otu_table(ps_gf_only_filt), "matrix")
asv_matrix_gf_only_np <- t(asv_matrix_gf_only_np)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_np_slr <- spiec.easi(asv_matrix_gf_only_np, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_gf_only_np_df <- create_ig_df(se_gf_only_np_slr, ps_gf_only_filt)
ig_slr_gf_only_np_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_np <- prep_ig(se_gf_only_np_slr, ps_gf_only_filt, ig_slr_gf_only_np_df)

igraph_gf_only_np <- plot_ig(ig_slr_gf_only_np) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_gf_only_np
ggsave("../Output/Networks/igraph_gf_only_np.svg", igraph_gf_only_np, width = 8, height = 5.5)

### CP ###
# Subset phyloseq for CP
ps_cp_only_filt_np <- ps_cp_gf_np_filt %>%
  subset_samples(population == "CP") # 160 samples

# Extract the abundance table (ASV table)
asv_matrix_cp_only_np <- as(otu_table(ps_cp_only_filt_np), "matrix")
asv_matrix_cp_only_np <- t(asv_matrix_cp_only_np)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_np_slr <- spiec.easi(asv_matrix_cp_only_np, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))
# Prepare for network plot
ig_slr_cp_only_np_df <- create_ig_df(se_cp_only_np_slr, ps_cp_only_filt)
ig_slr_cp_only_np_df %>% arrange(-weight)

 # Prepare for igraph
ig_slr_cp_only_np <- prep_ig(se_cp_only_np_slr, ps_cp_only_filt, ig_slr_cp_only_np_df)

igraph_cp_only_np <- plot_ig(ig_slr_cp_only_np) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_np
ggsave("../Output/Networks/igraph_cp_only_np.svg", igraph_cp_only_np, width = 8, height = 5.5)
```
#### Comparison metrics
```{r}
# Calculate network density
density_gf_np <- edge_density(ig_slr_gf_only_np)  # GF NP network
density_cpmatched_np <- edge_density(ig_slr_cp_only_np)  # CP NP network

# Calculate average degree
avg_degree_gf_np <- mean(degree(ig_slr_gf_only_np))
avg_degree_cpmatched_np <- mean(degree(ig_slr_cp_only_np))

# Calculate average path length
avg_path_length_gf_np <- mean_distance(ig_slr_gf_only_np, directed = FALSE)
avg_path_length_cpmatched_np <- mean_distance(ig_slr_cp_only_np, directed = FALSE)

# Calculate clustering coefficient
clustering_gf_np <- transitivity(ig_slr_gf_only_np, type = "global")
clustering_cpmatched_np <- transitivity(ig_slr_cp_only_np, type = "global")

# Calculate modularity
modularity_gf_np <- modularity(cluster_fast_greedy(ig_slr_gf_only_np))
modularity_cpmatched_np <- modularity(cluster_fast_greedy(ig_slr_cp_only_np))

# Combine metrics into a data frame
network_metrics_np_cp_gf <- data.frame(
  Metric = c(
    "Network Density", 
    "Average Degree", 
    "Average Path Length", 
    "Clustering Coefficient", 
    "Modularity"
  ),
  `GF NP` = c(
    density_gf_np, 
    avg_degree_gf_np, 
    avg_path_length_gf_np, 
    clustering_gf_np, 
    modularity_gf_np
  ),
  `CP NP` = c(
    density_cpmatched_np, 
    avg_degree_cpmatched_np, 
    avg_path_length_cpmatched_np, 
    clustering_cpmatched_np, 
    modularity_cpmatched_np
  )
)

# Print the table
print(network_metrics_np_cp_gf)

# Optionally save as a CSV for documentation
write.csv(network_metrics_np_cp_gf, "../Output/Networks/network_metrics_np_cp_gf.csv", row.names = FALSE)



# Looking at nodes
# For GF network
degree_centrality_gf <- degree(ig_slr_gf_only_np, mode = "all")
# For CP network
degree_centrality_cp <- degree(ig_slr_cp_only_np, mode = "all")

# For GF network
betweenness_centrality_gf <- betweenness(ig_slr_gf_only_np, directed = FALSE, normalized = TRUE)
# For CP network
betweenness_centrality_cp <- betweenness(ig_slr_cp_only_np, directed = FALSE, normalized = TRUE)


# GF network centralities
gf_metrics <- data.frame(
  ASV = names(degree_centrality_gf),
  Degree = degree_centrality_gf,
  Betweenness = betweenness_centrality_gf
)

# CP network centralities
cp_metrics <- data.frame(
  ASV = names(degree_centrality_cp),
  Degree = degree_centrality_cp,
  Betweenness = betweenness_centrality_cp
)


# Extract genus names for GF network
genus_names_gf <- V(ig_slr_gf_only_np)$Genus

# Extract genus names for CP network (if you have a CP igraph object)
genus_names_cp <- V(ig_slr_cp_only_np)$Genus

# For GF network - centrality metrics
gf_metrics <- data.frame(
  ASV = names(degree_centrality_gf),
  Degree = degree_centrality_gf,
  Betweenness = betweenness_centrality_gf
)

# Add genus names to GF metrics dataframe
gf_metrics$Genus <- genus_names_gf[match(gf_metrics$ASV, names(degree_centrality_gf))]

# For CP network - centrality metrics
cp_metrics <- data.frame(
  ASV = names(degree_centrality_cp),
  Degree = degree_centrality_cp,
  Betweenness = betweenness_centrality_cp
)

# Add genus names to CP metrics dataframe (if applicable)
cp_metrics$Genus <- genus_names_cp[match(cp_metrics$ASV, names(degree_centrality_cp))]

# Now your gf_metrics and cp_metrics dataframes will have the 'Genus' column
print(gf_metrics)
print(cp_metrics)



```


### OP
```{r}
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for op only 
ps_cp_gf_op <- ps_cp_gf %>%
  subset_samples(niche == "OP") # 287 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_op_filt <- ps_cp_gf_op %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 287 * 0.03, abund = 0.02) # 44 ASVs remaining


### GF ###
# Subset phyloseq for GF
ps_gf_only_filt_op <- ps_cp_gf_op_filt %>%
  subset_samples(population == "GF") # 92 samples

# Extract the abundance table (ASV table)
asv_matrix_gf_only_op <- as(otu_table(ps_gf_only_filt_op), "matrix")
asv_matrix_gf_only_op <- t(asv_matrix_gf_only_op)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_op_slr <- spiec.easi(asv_matrix_gf_only_op, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_gf_only_op_df <- create_ig_df(se_gf_only_op_slr, ps_gf_only_filt)
ig_slr_gf_only_op_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_op <- prep_ig(se_gf_only_op_slr, ps_gf_only_filt, ig_slr_gf_only_op_df)

igraph_gf_only_op <- plot_ig(ig_slr_gf_only_op) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_gf_only_op
ggsave("../Output/Networks/igraph_gf_only_op.svg", igraph_gf_only_op, width = 8, height = 5.5)

### CP ###
# Subset phyloseq for CP
ps_cp_only_filt_op <- ps_cp_gf_op_filt %>%
  subset_samples(population == "CP") # 195 samples

# Extract the abundance table (ASV table)
asv_matrix_cp_only_op <- as(otu_table(ps_cp_only_filt_op), "matrix")
asv_matrix_cp_only_op <- t(asv_matrix_cp_only_op)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_op_slr <- spiec.easi(asv_matrix_cp_only_op, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_op_df <- create_ig_df(se_cp_only_op_slr, ps_cp_only_filt)
ig_slr_cp_only_op_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_cp_only_op <- prep_ig(se_cp_only_op_slr, ps_cp_only_filt, ig_slr_cp_only_op_df)

igraph_cp_only_op <- plot_ig(ig_slr_cp_only_op) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_op
ggsave("../Output/Networks/igraph_cp_only_op.svg", igraph_cp_only_op, width = 8, height = 5.5)
```

#### Comparison metrics
```{r}
# Calculate network density
density_gf_op <- edge_density(ig_slr_gf_only_op)  # GF op network
density_cpmatched_op <- edge_density(ig_slr_cp_only_op)  # CP op network

# Calculate average degree
avg_degree_gf_op <- mean(degree(ig_slr_gf_only_op))
avg_degree_cpmatched_op <- mean(degree(ig_slr_cp_only_op))

# Calculate average path length
avg_path_length_gf_op <- mean_distance(ig_slr_gf_only_op, directed = FALSE)
avg_path_length_cpmatched_op <- mean_distance(ig_slr_cp_only_op, directed = FALSE)

# Calculate clustering coefficient
clustering_gf_op <- transitivity(ig_slr_gf_only_op, type = "global")
clustering_cpmatched_op <- transitivity(ig_slr_cp_only_op, type = "global")

# Calculate modularity
modularity_gf_op <- modularity(cluster_fast_greedy(ig_slr_gf_only_op))
modularity_cpmatched_op <- modularity(cluster_fast_greedy(ig_slr_cp_only_op))

# Combine metrics into a data frame
network_metrics_op_cp_gf <- data.frame(
  Metric = c(
    "Network Density", 
    "Average Degree", 
    "Average Path Length", 
    "Clustering Coefficient", 
    "Modularity"
  ),
  `GF op` = c(
    density_gf_op, 
    avg_degree_gf_op, 
    avg_path_length_gf_op, 
    clustering_gf_op, 
    modularity_gf_op
  ),
  `CP op` = c(
    density_cpmatched_op, 
    avg_degree_cpmatched_op, 
    avg_path_length_cpmatched_op, 
    clustering_cpmatched_op, 
    modularity_cpmatched_op
  )
)

# Print the table
print(network_metrics_op_cp_gf)

# optionally save as a CSV for documentation
write.csv(network_metrics_op_cp_gf, "../Output/Networks/network_metrics_op_cp_gf.csv", row.names = FALSE)
```

# Networks on the genus level
## Farmers  vs residents
### NP
```{r}
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for NP only 
ps_cp_gf_np <- ps_cp_gf %>%
  subset_samples(niche == "NP") # 237 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_np_filt <- ps_cp_gf_np %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 237 * 0.03, abund = 0.01) # 33 ASVs remaining

### GF ###
# Subset phyloseq for GF
ps_gf_only_filt <- ps_cp_gf_np_filt %>%
  subset_samples(population == "GF") # 77 samples

# Aggregate to genus level
ps_gf_only_filt_genus <- tax_glom(ps_gf_only_filt, taxrank = "Genus")

# Extract the abundance table (ASV table)
asv_matrix_gf_only_np_genus <- as(otu_table(ps_gf_only_filt_genus), "matrix")
asv_matrix_gf_only_np_genus <- t(asv_matrix_gf_only_np_genus)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_np_slr_genus <- spiec.easi(asv_matrix_gf_only_np_genus, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_gf_only_np_genus_df <- create_ig_df(se_gf_only_np_slr_genus, ps_gf_only_filt_genus)
ig_slr_gf_only_np_genus_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_np_genus <- prep_ig(se_gf_only_np_slr_genus, ps_gf_only_filt_genus, ig_slr_gf_only_np_genus_df)

igraph_gf_only_np_genus <- plot_ig_genus(ig_slr_gf_only_np_genus) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_gf_only_np_genus
ggsave("../Output/Networks/igraph_gf_only_np_genus_level.svg", igraph_gf_only_np_genus, width = 8, height = 5.5)

### CP ###
# Subset phyloseq for cp
ps_cp_only_filt <- ps_cp_gf_np_filt %>%
  subset_samples(population == "CP") # 160 samples

# Aggregate to genus level
ps_cp_only_filt_genus <- tax_glom(ps_cp_only_filt, taxrank = "Genus")

# Extract the abundance table (ASV table)
asv_matrix_cp_only_np_genus <- as(otu_table(ps_cp_only_filt_genus), "matrix")
asv_matrix_cp_only_np_genus <- t(asv_matrix_cp_only_np_genus)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_np_slr_genus <- spiec.easi(asv_matrix_cp_only_np_genus, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_np_genus_df <- create_ig_df(se_cp_only_np_slr_genus, ps_cp_only_filt_genus)
ig_slr_cp_only_np_genus_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_cp_only_np_genus <- prep_ig(se_cp_only_np_slr_genus, ps_cp_only_filt_genus, ig_slr_cp_only_np_genus_df)

igraph_cp_only_np_genus <- plot_ig_genus(ig_slr_cp_only_np_genus) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_np_genus
ggsave("../Output/Networks/igraph_cp_only_np_genus_level.svg", igraph_cp_only_np_genus, width = 8, height = 5.5)

```
#### Comparison metrics
```{r}
# Calculate network density
density_gf_np_genus <- edge_density(ig_slr_gf_only_np_genus)  # GF NP network
density_cpmatched_np_genus <- edge_density(ig_slr_cp_only_np_genus)  # CP NP network

# Calculate average degree
avg_degree_gf_np_genus <- mean(degree(ig_slr_gf_only_np_genus))
avg_degree_cpmatched_np_genus <- mean(degree(ig_slr_cp_only_np_genus))

# Calculate average path length
avg_path_length_gf_np_genus <- mean_distance(ig_slr_gf_only_np_genus, directed = FALSE)
avg_path_length_cpmatched_np_genus <- mean_distance(ig_slr_cp_only_np_genus, directed = FALSE)

# Calculate clustering coefficient
clustering_gf_np_genus <- transitivity(ig_slr_gf_only_np_genus, type = "global")
clustering_cpmatched_np_genus <- transitivity(ig_slr_cp_only_np_genus, type = "global")

# Calculate modularity
modularity_gf_np_genus <- modularity(cluster_fast_greedy(ig_slr_gf_only_np_genus))
modularity_cpmatched_np_genus <- modularity(cluster_fast_greedy(ig_slr_cp_only_np_genus))

# Combine metrics into a data frame
network_metrics_np_cp_gf_genus <- data.frame(
  Metric = c(
    "Network Density", 
    "Average Degree", 
    "Average Path Length", 
    "Clustering Coefficient", 
    "Modularity"
  ),
  `GF NP` = c(
    density_gf_np_genus, 
    avg_degree_gf_np_genus, 
    avg_path_length_gf_np_genus, 
    clustering_gf_np_genus, 
    modularity_gf_np_genus
  ),
  `CP NP` = c(
    density_cpmatched_np_genus, 
    avg_degree_cpmatched_np_genus, 
    avg_path_length_cpmatched_np_genus, 
    clustering_cpmatched_np_genus, 
    modularity_cpmatched_np_genus
  )
)

# Print the table
print(network_metrics_np_cp_gf_genus)

# Optionally save as a CSV for documentation
write.csv(network_metrics_np_cp_gf_genus, "../Output/Networks/network_metrics_np_cp_gf_genus.csv", row.names = FALSE)


```


### OP
```{r}
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for op only 
ps_cp_gf_op <- ps_cp_gf %>%
  subset_samples(niche == "OP") # 287 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_op_filt <- ps_cp_gf_op %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 287 * 0.03, abund = 0.02) # 44 ASVs remaining

### GF ###
# Subset phyloseq for GF
ps_gf_only_filt <- ps_cp_gf_op_filt %>%
  subset_samples(population == "GF") # 92 samples

# Aggregate to genus level
ps_gf_only_filt_genus <- tax_glom(ps_gf_only_filt, taxrank = "Genus")

# Extract the abundance table (ASV table)
asv_matrix_gf_only_op_genus <- as(otu_table(ps_gf_only_filt_genus), "matrix")
asv_matrix_gf_only_op_genus <- t(asv_matrix_gf_only_op_genus)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_op_slr_genus <- spiec.easi(asv_matrix_gf_only_op_genus, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_gf_only_op_genus_df <- create_ig_df(se_gf_only_op_slr_genus, ps_gf_only_filt_genus)
ig_slr_gf_only_op_genus_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_op_genus <- prep_ig(se_gf_only_op_slr_genus, ps_gf_only_filt_genus, ig_slr_gf_only_op_genus_df)

igraph_gf_only_op_genus <- plot_ig_genus(ig_slr_gf_only_op_genus) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_gf_only_op_genus
ggsave("../Output/Networks/igraph_gf_only_op_genus_level.svg", igraph_gf_only_op_genus, width = 8, height = 5.5)

### CP ###
# Subset phyloseq for cp
ps_cp_only_filt <- ps_cp_gf_op_filt %>%
  subset_samples(population == "CP") # 195 samples

# Aggregate to genus level
ps_cp_only_filt_genus <- tax_glom(ps_cp_only_filt, taxrank = "Genus")

# Extract the abundance table (ASV table)
asv_matrix_cp_only_op_genus <- as(otu_table(ps_cp_only_filt_genus), "matrix")
asv_matrix_cp_only_op_genus <- t(asv_matrix_cp_only_op_genus)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_op_slr_genus <- spiec.easi(asv_matrix_cp_only_op_genus, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_op_genus_df <- create_ig_df(se_cp_only_op_slr_genus, ps_cp_only_filt_genus)
ig_slr_cp_only_op_genus_df %>% arrange(-weight)

# Prepare for igraph
ig_slr_cp_only_op_genus <- prep_ig(se_cp_only_op_slr_genus, ps_cp_only_filt_genus, ig_slr_cp_only_op_genus_df)

igraph_cp_only_op_genus <- plot_ig_genus(ig_slr_cp_only_op_genus) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_op_genus
ggsave("../Output/Networks/igraph_cp_only_op_genus_level.svg", igraph_cp_only_op_genus, width = 8, height = 5.5)

```

# Patchwork figures
```{r}
# ASV level
# NP 
combined_plot_np <- igraph_gf_only_np + igraph_cp_only_np + plot_layout(ncol = 2)
print(combined_plot_np)
ggsave("../Output/Networks/combined_network_NP.svg", combined_plot_np, width = 16, height = 5.5)

# OP 
combined_plot_op <- igraph_gf_only_op + igraph_cp_only_op + plot_layout(ncol = 2)
print(combined_plot_op)
ggsave("../Output/Networks/combined_network_OP.svg", combined_plot_op, width = 16, height = 5.5)



# Genus level 
# NP 
combined_plot_np_genus <- igraph_gf_only_np_genus + igraph_cp_only_np_genus + plot_layout(ncol = 2)
print(combined_plot_np_genus)
ggsave("../Output/Networks/combined_network_NP_genus.svg", combined_plot_np_genus, width = 16, height = 5.5)

# OP 
combined_plot_op_genus <- igraph_gf_only_op_genus + igraph_cp_only_op_genus + plot_layout(ncol = 2)
print(combined_plot_op_genus)
ggsave("../Output/Networks/combined_network_OP_genus.svg", combined_plot_op_genus, width = 16, height = 5.5)
```

# Filtering of data based on power law
## Farmers vs residents
### NP 
```{r}
# Now I try filtering taxa based on their degree in the network
# Such filtering focuses on the importance of nodes in the network rather than their abundance or prevalence in the original dataset.
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for NP only 
ps_cp_gf_np <- ps_cp_gf %>%
  subset_samples(niche == "NP") # 237 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_np <- ps_cp_gf_np %>%  
  prune_taxa(taxa_sums(.) > 0, .) 

# Extract the abundance table (ASV table)
asv_matrix_cp_gf_np <- as(otu_table(ps_cp_gf_np), "matrix")
asv_matrix_cp_gf_np <- t(asv_matrix_cp_gf_np)

# Sum each column of the ASV matrix i.e. sum the abundance of each ASV across all samples 
column_sums <- colSums(asv_matrix_cp_gf_np) 

# Create a new dataframe with the column names as row names and the sums as values
sum_df <- data.frame(
  ASV = names(column_sums),
  Sum = column_sums
)
rownames(sum_df) <- NULL

# Sort the sums in descending order -i.e. most abundant first
sum_df_sorted <- sum_df[order(-sum_df$Sum), ]

# Log-transform the sums 
sum_df_sorted <- sum_df_sorted %>%
  mutate(log_sum = log10(Sum + 1))  # Log-transform

# Check the distribution of all ASV sums
line_plot_sums <- ggplot(sum_df_sorted, aes(x = seq_along(Sum), y = Sum)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Distribution of Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )
# Looks like a power law distribution

# Log sums plot
line_plot_log <- ggplot(sum_df_sorted, aes(x = seq_along(log_sum), y = log_sum)) +  # Use index for x-axis
  geom_line() +
  theme_minimal() +  # Clean theme
  labs(
    title = "Distribution of log Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum (log)"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )

# Fit the power-law model to the log_sum values and estimate the xmin threshold
power_law_model <- conpl$new(sum_df_sorted$log_sum)  # Initialize power-law model on log_sum
xmin_estimation <- estimate_xmin(power_law_model)  # Estimate xmin
power_law_model$setXmin(xmin_estimation)  # Set xmin for the model
xmin <- xmin_estimation$xmin  # Extract xmin = 3.21801
ntail <- xmin_estimation$ntail  # Extract the number of points in the tail region (i.e those that follow the power law distribution) = 154

# Select tail data based on the model - i.e. select the "tail" data points: the ASVs whose log-transformed summed abundance is greater than or equal to the estimated xmin threshold.
# These ASVs are considered the most interesting in the network based on their position in the power-law tail (indicating that they have a disproportionate influence or importance).
tail_indices <- which(sum_df_sorted$log_sum >= xmin)  # Find indices for the tail region
tail_data <- sum_df_sorted[tail_indices, ]  # Use indices to subset the data
# Save as data table
tail_ASVs <- data.table(unique(tail_data$ASV))

# Save the tail data
write.csv(tail_data, "../Output/Networks/Power_law/Power_law_ASV_selection.csv", row.names = FALSE)

# Save key results into a table
pl_results <- data.frame(
  xmin = xmin,
  pars = power_law_model$pars,  # Power-law parameters
  ntail = ntail,
  distance = xmin_estimation$distance,  # Distance metric
  gof = xmin_estimation$gof  # Goodness of fit
)
write.csv(pl_results, "../Output/Networks/Power_law/Power_law_model_results.csv", row.names = FALSE)


# Subset the original phyloseq object (ps_cp_gf_np) to retain only the 154 ASVs identified in the
# Load the tail ASVs (from the previous code) into a vector
tail_ASVs_vector <- tail_ASVs$V1  # Extract ASV names (assuming 'V1' is the column containing the ASV names)

# Subset the phyloseq object to retain only the selected ASVs
ps_cp_gf_np_plsubset <- prune_taxa(taxa_names(ps_cp_gf_np) %in% tail_ASVs_vector, ps_cp_gf_np)
ps_cp_gf_np_plsubset # Now only 154 taxa 


#### GF ####
# Subset phyloseq for GF
ps_gf_only_np_plsubset <- ps_cp_gf_np_plsubset %>%
  subset_samples(population == "GF") # 77 samples, 154 taxa

# Prune zero sum taxa
ps_gf_only_np_plsubset <- ps_gf_only_np_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 128 taxa remaining

# Extract the abundance table (ASV table)
asv_matrix_gf_only_np_plsubset <- as(otu_table(ps_gf_only_np_plsubset), "matrix")
asv_matrix_gf_only_np_plsubset <- t(asv_matrix_gf_only_np_plsubset)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_np_slr_plsubset <- spiec.easi(asv_matrix_gf_only_np_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_gf_only_np_df_plsubset <- create_ig_df(se_gf_only_np_slr_plsubset, ps_gf_only_np_plsubset)
ig_slr_gf_only_np_df_plsubset %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_np_plsubset <- prep_ig(se_gf_only_np_slr_plsubset, ps_gf_only_np_plsubset, ig_slr_gf_only_np_df_plsubset)


# Plot the network with degree-based node sizing
igraph_gf_only_np_plsubset_size <- plot_ig_nodal_size(ig_slr_gf_only_np_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_gf_only_np_pl_nodaldegree.svg", igraph_gf_only_np_plsubset_size, width = 8, height = 5.5)


# Plot the network with betweeness centrality-based node sizing
igraph_gf_only_np_plsubset_betweenesscentrality <- plot_ig_betweeness_centrality(ig_slr_gf_only_np_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_gf_only_np_plsubset_betweenesscentrality.svg", igraph_gf_only_np_plsubset_betweenesscentrality, width = 8, height = 5.5)


#### CP ####
# Subset phyloseq for CP
ps_cp_only_np_plsubset <- ps_cp_gf_np_plsubset %>%
  subset_samples(population == "CP") # 160 samples, 154 taxa

# Prune zero sum taxa
ps_cp_only_np_plsubset <- ps_cp_only_np_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 139 taxa remaining

# Extract the abundance table (ASV table)
asv_matrix_cp_only_np_plsubset <- as(otu_table(ps_cp_only_np_plsubset), "matrix")
asv_matrix_cp_only_np_plsubset <- t(asv_matrix_cp_only_np_plsubset)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_np_slr_plsubset <- spiec.easi(asv_matrix_cp_only_np_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_np_df_plsubset <- create_ig_df(se_cp_only_np_slr_plsubset, ps_cp_only_np_plsubset)
ig_slr_cp_only_np_df_plsubset %>% arrange(-weight)

# Prepare for igraph
ig_slr_cp_only_np_plsubset <- prep_ig(se_cp_only_np_slr_plsubset, ps_cp_only_np_plsubset, ig_slr_cp_only_np_df_plsubset)


# Plot the network with degree-based node sizing
igraph_cp_only_np_plsubset_size <- plot_ig_nodal_size(ig_slr_cp_only_np_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_cp_only_np_pl_nodaldegree.svg", igraph_cp_only_np_plsubset_size, width = 8, height = 5.5)


# Plot the network with betweeness centrality-based node sizing
igraph_cp_only_np_plsubset_betweenesscentrality <- plot_ig_betweeness_centrality(ig_slr_cp_only_np_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_cp_only_np_plsubset_betweenesscentrality.svg", igraph_cp_only_np_plsubset_betweenesscentrality, width = 8, height = 5.5)
```
### OP 
## Farmers vs residents
```{r}
# Now I try filtering taxa based on their degree in the network
# Such filtering focuses on the importance of nodes in the network rather than their abundance or prevalence in the original dataset.
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for op only 
ps_cp_gf_op <- ps_cp_gf %>%
  subset_samples(niche == "OP") # 287 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_op <- ps_cp_gf_op %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 3411 taxa

# Add an extra filter as there are too many taxa in the OP after applying power law cut off
# Calculate prevalence for each ASV
prevalence <- apply(otu_table(ps_cp_gf_op), 1, function(x) sum(x > 0) / nsamples(ps_cp_gf_op))
# Filter taxa based on prevalence (e.g., keep taxa present in at least 10% of samples)
prevalence_threshold <- 0.1
taxa_to_keep <- names(prevalence[prevalence >= prevalence_threshold])
# Prune the phyloseq object to retain only the selected taxa
ps_cp_gf_op_filt <- prune_taxa(taxa_to_keep, ps_cp_gf_op) # 243 taxa, 287 samples


# Extract the abundance table (ASV table)
asv_matrix_cp_gf_op <- as(otu_table(ps_cp_gf_op_filt), "matrix")
asv_matrix_cp_gf_op <- t(asv_matrix_cp_gf_op)

# Sum each column of the ASV matrix i.e. sum the abundance of each ASV across all samples 
column_sums_op <- colSums(asv_matrix_cp_gf_op) 

# Create a new dataframe with the column names as row names and the sums as values
sum_df_op <- data.frame(
  ASV = names(column_sums_op),
  Sum = column_sums_op
)
rownames(sum_df_op) <- NULL

# Sort the sums in descending order -i.e. most abundant first
sum_df_op_sorted <- sum_df_op[order(-sum_df_op$Sum), ]

# Log-transform the sums 
sum_df_op_sorted <- sum_df_op_sorted %>%
  mutate(log_sum = log10(Sum + 1))  # Log-transform

# Check the distribution of all ASV sums
line_plot_sums_op <- ggplot(sum_df_op_sorted, aes(x = seq_along(Sum), y = Sum)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Distribution of Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )
# Looks like a power law distribution

# Log sums plot
line_plot_log_op <- ggplot(sum_df_op_sorted, aes(x = seq_along(log_sum), y = log_sum)) +  # Use index for x-axis
  geom_line() +
  theme_minimal() +  # Clean theme
  labs(
    title = "Distribution of log Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum (log)"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )

# # Fit the power-law model to the log_sum values and estimate the xmin threshold
power_law_model_op <- conpl$new(sum_df_op_sorted$log_sum)  # Initialize power-law model on log_sum
xmin_estimation_op <- estimate_xmin(power_law_model_op)  # Estimate xmin
power_law_model_op$setXmin(xmin_estimation_op)  # Set xmin for the model
xmin_op <- xmin_estimation_op$xmin  # Extract xmin = 3.915294
ntail_op <- xmin_estimation_op$ntail  # Extract the number of points in the tail region (i.e those that follow the power law distribution) = 96

# Select tail data based on the model - i.e. select the "tail" data points: the ASVs whose log-transformed summed abundance is greater than or equal to the estimated xmin threshold.
# These ASVs are considered the most interesting in the network based on their position in the power-law tail (indicating that they have a disproportionate influence or importance).
tail_indices_op <- which(sum_df_op_sorted$log_sum >= xmin_op)  # Find indices for the tail region
tail_data_op <- sum_df_op_sorted[tail_indices_op, ]  # Use indices to subset the data
# Save as data table
tail_ASVs_op <- data.table(unique(tail_data_op$ASV))

# Save the tail data
write.csv(tail_data_op, "../Output/Networks/Power_law/Power_law_ASV_selection_op.csv", row.names = FALSE)

# Save key results into a table
pl_results_op <- data.frame(
  xmin = xmin_op,
  pars = power_law_model_op$pars,  # Power-law parameters
  ntail = ntail_op,
  distance = xmin_estimation_op$distance,  # Distance metric
  gof = xmin_estimation_op$gof  # Goodness of fit
)
write.csv(pl_results_op, "../Output/Networks/Power_law/Power_law_model_results_op.csv", row.names = FALSE)


# Subset the original phyloseq object (ps_cp_gf_np) to retain only the 154 ASVs identified in the
# Load the tail ASVs (from the previous code) into a vector
tail_ASVs_vector_op <- tail_ASVs_op$V1  # Extract ASV names (assuming 'V1' is the column containing the ASV names)

# Subset the phyloseq object to retain only the selected ASVs
ps_cp_gf_op_plsubset <- prune_taxa(taxa_names(ps_cp_gf_op_filt) %in% tail_ASVs_vector_op, ps_cp_gf_op_filt)
ps_cp_gf_op_plsubset # Now only 96 taxa 


#### GF ####
# Subset phyloseq for GF
ps_gf_only_op_plsubset <- ps_cp_gf_op_plsubset %>%
  subset_samples(population == "GF") # 92 samples, 96 taxa

# Prune zero sum taxa
ps_gf_only_op_plsubset <- ps_gf_only_op_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 94 taxa remaining

# Extract the abundance table (ASV table)
asv_matrix_gf_only_op_plsubset <- as(otu_table(ps_gf_only_op_plsubset), "matrix")
asv_matrix_gf_only_op_plsubset <- t(asv_matrix_gf_only_op_plsubset)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_op_slr_plsubset <- spiec.easi(asv_matrix_gf_only_op_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))


# Prepare for network plot
ig_slr_gf_only_op_df_plsubset <- create_ig_df(se_gf_only_op_slr_plsubset, ps_gf_only_op_plsubset)
ig_slr_gf_only_op_df_plsubset %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_op_plsubset <- prep_ig(se_gf_only_op_slr_plsubset, ps_gf_only_op_plsubset, ig_slr_gf_only_op_df_plsubset)

# Plot the network with degree-based node sizing
igraph_gf_only_op_plsubset_nodaldegree <- plot_ig_nodal_size(ig_slr_gf_only_op_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_gf_only_op_pl_nodaldegree.svg", igraph_gf_only_op_plsubset_nodaldegree, width = 8, height = 5.5)


# Plot the network with betweeness centrality-based node sizing
igraph_gf_only_op_plsubset_betweenesscentrality <- plot_ig_betweeness_centrality(ig_slr_gf_only_op_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_gf_only_op_plsubset_betweenesscentrality.svg", igraph_gf_only_op_plsubset_betweenesscentrality, width = 8, height = 5.5)


#### CP ####
# Subset phyloseq for CP
ps_cp_only_op_plsubset <- ps_cp_gf_op_plsubset %>%
  subset_samples(population == "CP") # 195 samples, 96 taxa

# Prune zero sum taxa
ps_cp_only_op_plsubset <- ps_cp_only_op_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # all (96) taxa remaining

# Extract the abundance table (ASV table)
asv_matrix_cp_only_op_plsubset <- as(otu_table(ps_cp_only_op_plsubset), "matrix")
asv_matrix_cp_only_op_plsubset <- t(asv_matrix_cp_only_op_plsubset)

saveRDS(asv_matrix_cp_only_op_plsubset, "../Output/Networks/Power_law/asv_matrix_cp_only_op_plsubset.rds")

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_op_slr_plsubset <- spiec.easi(asv_matrix_cp_only_op_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

readRDS("../Output/Networks/Power_law/se_cp_only_op_slr_plsubset.rds")

# Prepare for network plot
ig_slr_cp_only_op_df_plsubset <- create_ig_df(se_cp_only_op_slr_plsubset, ps_cp_only_op_plsubset)
ig_slr_cp_only_op_df_plsubset %>% arrange(-weight)

# Prepare for igraph
ig_slr_cp_only_op_plsubset <- prep_ig(se_cp_only_op_slr_plsubset, ps_cp_only_op_plsubset, ig_slr_cp_only_op_df_plsubset)

# Plot the network with degree-based node sizing
igraph_cp_only_op_plsubset_size <- plot_ig_nodal_size(ig_slr_cp_only_op_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_cp_only_op_pl_nodaldegree.svg", igraph_cp_only_op_plsubset_size, width = 8, height = 5.5)


# Plot the network with betweeness centrality-based node sizing
igraph_cp_only_op_plsubset_betweenesscentrality <- plot_ig_betweeness_centrality(ig_slr_cp_only_op_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/igraph_cp_only_op_plsubset_betweenesscentrality.svg", igraph_cp_only_op_plsubset_betweenesscentrality, width = 8, height = 5.5)
```
# Patchwork figures of power law networks
```{r}
# NP 
combined_plot_np_nodal_degree <- igraph_gf_only_np_plsubset_size + igraph_cp_only_np_plsubset_size + plot_layout(ncol = 2)
print(combined_plot_np_nodal_degree)
ggsave("../Output/Networks/Power_law/combined_network_NP_nodal_degree.svg", combined_plot_np_nodal_degree, width = 16, height = 5.5)

# OP 
combined_plot_op <- igraph_gf_only_op + igraph_cp_only_op + plot_layout(ncol = 2)
print(combined_plot_op)
ggsave("../Output/Networks/combined_network_OP.svg", combined_plot_op, width = 16, height = 5.5)

```


<!-- ### Genus level -->
<!-- ```{r} -->
<!-- # Subset phyloseq for GF -->
<!-- ps_gf_only_np_plsubset <- ps_cp_gf_np_plsubset %>% -->
<!--   subset_samples(population == "GF") # 77 samples, 154 taxa -->

<!-- # Prune zero sum taxa -->
<!-- ps_gf_only_np_plsubset <- ps_gf_only_np_plsubset %>%   -->
<!--   prune_taxa(taxa_sums(.) > 0, .) # 128 taxa remaining -->

<!-- # Aggregate to genus level -->
<!-- ps_gf_only_np_plsubset_genus <- tax_glom(ps_gf_only_np_plsubset, taxrank = "Genus") -->

<!-- # Extract the abundance table (ASV table) -->
<!-- asv_matrix_gf_only_np_plsubset_genus <- as(otu_table(ps_gf_only_np_plsubset_genus), "matrix") -->
<!-- asv_matrix_gf_only_np_plsubset_genus <- t(asv_matrix_gf_only_np_plsubset_genus) -->


<!-- # No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads -->
<!-- se_gf_only_np_slr_plsubset_genus <- spiec.easi(asv_matrix_gf_only_np_plsubset_genus,  -->
<!--                            method ='slr',  -->
<!--                            r = 5,  -->
<!--                            lambda.min.ratio = 1e-1, -->
<!--                            nlambda = 30,  -->
<!--                            pulsar.params=list(rep.num = 50)) -->

<!-- # Prepare for network plot -->
<!-- ig_slr_gf_only_np_df_plsubset_genus <- create_ig_df(se_gf_only_np_slr_plsubset_genus, ps_gf_only_np_plsubset_genus) -->
<!-- ig_slr_gf_only_np_df_plsubset_genus %>% arrange(-weight) -->

<!-- # Prepare for igraph -->
<!-- ig_slr_gf_only_np_plsubset_genus <- prep_ig(se_gf_only_np_slr_plsubset_genus, ps_gf_only_np_plsubset_genus, ig_slr_gf_only_np_df_plsubset_genus) -->


<!-- # Plot the network with degree-based node sizing -->
<!-- igraph_gf_only_np_plsubset_size_genus <- plot_ig_nodal_size(ig_slr_gf_only_np_plsubset_genus) + -->
<!--   theme_minimal() + # Use a clean theme -->
<!--   theme( -->
<!--     panel.background = element_rect(fill = "white", color = NA), # White panel background -->
<!--     plot.background = element_rect(fill = "white", color = NA),  # White plot background -->
<!--     axis.line = element_blank(),      # Removes x and y axis lines -->
<!--     axis.ticks = element_blank(),     # Removes axis ticks -->
<!--     axis.text = element_blank(),      # Removes axis text -->
<!--     axis.title = element_blank(),     # Removes axis titles -->
<!--     legend.text = element_text(size = 10), # Adjusts size of legend text -->
<!--     legend.title = element_text(size = 10), # Adjusts size of legend title -->
<!--     legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items -->
<!--     legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller -->
<!--     legend.position = "right",  # Keeps legend position on the right -->
<!--     panel.grid = element_blank(),  # Remove all grid lines (guidelines) -->

<!--   ) -->

<!-- # Save the plot -->
<!-- ggsave("../Output/Networks/Power_law/igraph_gf_only_np_pl_nodaldegree_genus.svg", igraph_gf_only_np_plsubset_size_genus, width = 8, height = 5.5) -->


<!-- # Plot the network with betweeness centrality-based node sizing -->
<!-- igraph_gf_only_np_plsubset_betweenesscentrality <- plot_ig_betweeness_centrality(ig_slr_gf_only_np_plsubset) + -->
<!--   theme_minimal() + # Use a clean theme -->
<!--   theme( -->
<!--     panel.background = element_rect(fill = "white", color = NA), # White panel background -->
<!--     plot.background = element_rect(fill = "white", color = NA),  # White plot background -->
<!--     axis.line = element_blank(),      # Removes x and y axis lines -->
<!--     axis.ticks = element_blank(),     # Removes axis ticks -->
<!--     axis.text = element_blank(),      # Removes axis text -->
<!--     axis.title = element_blank(),     # Removes axis titles -->
<!--     legend.text = element_text(size = 10), # Adjusts size of legend text -->
<!--     legend.title = element_text(size = 10), # Adjusts size of legend title -->
<!--     legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items -->
<!--     legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller -->
<!--     legend.position = "right",  # Keeps legend position on the right -->
<!--     panel.grid = element_blank(),  # Remove all grid lines (guidelines) -->

<!--   ) -->

<!-- # Save the plot -->
<!-- ggsave("../Output/Networks/Power_law/igraph_gf_only_np_plsubset_betweenesscentrality.svg", igraph_gf_only_np_plsubset_betweenesscentrality, width = 8, height = 5.5) -->

<!-- ``` -->





