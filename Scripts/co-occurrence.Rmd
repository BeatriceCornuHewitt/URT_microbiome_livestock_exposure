---
title: "Networks Spiec-easi"
author: "Beatrice Cornu Hewitt" 
date: "`r Sys.time()`"
---

Spiec-easi made for microbiome co-occurrence networks
# Libraries 
```{r}
# Install required packages
# Load libraries
library(phyloseq)
library(dplyr)
library(devtools)
library(pulsar)
library(MASS)
library(igraph)
library(ggplot2)
library(purrr)
library(patchwork)
library(poweRlaw)
library(data.table)
library(RColorBrewer)
library(ggraph)

# install_github("zdk123/SpiecEasi")
library(SpiecEasi)
#install_github("vallenderlab/MicrobiomeR") # Install the package
library(microbiomer)
```

# Functions 
```{r}
# Functions for network creation
get_edge_weights_slr <- function(se) {
  se.icov <- se$select$est$icov[[getOptInd(se)]]
  se.cov <- solve(se.icov)
  return(list(se.icov = se.icov, se.cov = se.cov))
  # https://github.com/zdk123/SpiecEasi/issues/198
}


get_igraph_edges <- function(se) {
  se.cov <- get_edge_weights_slr(se)$se.cov
  se.weighted <- graph.adjacency(se.cov * getRefit(se), mode = "undirected", weighted = TRUE, diag = FALSE)
  # https://github.com/zdk123/SpiecEasi/issues/198
  return(se.weighted)
}

create_ig_df <- function(se_slr, ps_filt) {
  ig_slr_fae_df <- get.data.frame(get_igraph_edges(se_slr), what = c("edges")) %>% #se_slr_fae
    mutate(from = taxa_names(ps_filt)[from],
           to = taxa_names(ps_filt)[to]) 
  
}

prep_ig <- function(se_slr, ps_filt, ig_df) {
  
  get_list_of_columns <- function(df) { 
    list_cols <- map(seq_len(ncol(df)), ~df[,.x]) 
    names(list_cols) <- colnames(df)
    return(list_cols)
  }
ig_slr <- adj2igraph(getRefit(se_slr),  
                       vertex.attr = get_list_of_columns(tax_table(ps_filt) %>% as(., "matrix"))) %>%
    set_edge_attr(name = "edge_width", value = abs(ig_df$weight)) %>% 
    set_edge_attr(name = "sign", value = if_else(ig_df$weight < 0, "neg", "pos")) 
  return(ig_slr)
}


plot_ig_nodal_size <- function(ig) {
  # Extract unique families and define colors
  unique_order <- unique(V(ig)$Order)  # Get unique families
  num_colors <- length(unique_order)  # Count families
  my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(num_colors)  # Generate a color palette

  # Calculate degree and add it as a vertex attribute
  V(ig)$degree <- igraph::degree(ig)  # Calculate degree for each node

  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>%  # Remove nodes with degree 0
    ggraph(layout = "fr") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +  # Set edge colors
    geom_node_point(shape = 20, aes(colour = Order, size = degree), alpha = 0.8) +  # Map size to degree
    scale_colour_manual(values = setNames(my_colors, unique_order)) +  # Assign colors to families
    scale_size_continuous(range = c(5, 20), guide = "none") +  # Adjust size range for nodes
    geom_node_text(aes(label = ASV), repel = TRUE, size = 3, max.overlaps = 50) +  # Adjust `max.overlaps`
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      legend.text = element_text(size = 8),  # Adjust legend text size
      legend.title = element_text(size = 10),  # Adjust legend title size
      legend.spacing = unit(0.5, "lines"),  # Adjust spacing in the legend
      legend.key.size = unit(0.5, "lines"),  # Adjust key size in the legend
      legend.position = "right"
    ) +
    guides(
      colour = guide_legend(
        override.aes = list(size = 4)  # Adjust legend symbol size
      ),
      edge_width = "none"  # Hide edge width in the legend
    )
}

# Networks with selected labelling of ASVs in the network
# labelling only interestring nodes
plot_ig_nodal_size_selected_labels <- function(ig, selected_asvs) {
  # Extract unique families and define colors
  unique_order <- unique(V(ig)$Order)
  num_colors <- length(unique_order)
  my_colors <- colorRampPalette(brewer.pal(9, "Set3"))(num_colors)
  
  # Calculate degree
  V(ig)$degree <- igraph::degree(ig)

  # Identify nodes to label
  selected_indices <- which(V(ig)$ASV %in% selected_asvs)  # Indices of selected ASVs
  neighbors <- unlist(ego(ig, order = 1, nodes = selected_indices))  # Neighbors of selected ASVs
  to_label <- unique(c(selected_indices, neighbors))  # Combine selected ASVs and their neighbors
  V(ig)$label <- ifelse(seq_along(V(ig)) %in% to_label, V(ig)$ASV, NA)  # Set labels for nodes to label
  
  ig %>%
    delete_vertices(which(igraph::degree(.) == 0)) %>%
    ggraph(layout = "fr") +
    geom_edge_link(aes(colour = sign, width = edge_width), alpha = 0.5) +
    scale_edge_color_manual(values = c("neg" = "darkblue", "pos" = "darkred")) +
    geom_node_point(shape = 20, aes(colour = Order, size = degree), alpha = 0.8) +
    scale_colour_manual(values = setNames(my_colors, unique_order)) +
    scale_size_continuous(range = c(5, 20), guide = "none") +
    geom_node_text(aes(label = label), repel = TRUE, size = 3, max.overlaps = 50) +  # Use the new `label` column
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      axis.line = element_blank(),
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 10),
      legend.spacing = unit(0.5, "lines"),
      legend.key.size = unit(0.5, "lines"),
      legend.position = "right"
    ) +
    guides(
      colour = guide_legend(override.aes = list(size = 4)),
      edge_width = "none"
    )
}

```
# NP vs OP networks
## CP (all) NP
```{r}
# Data for all
ps <- readRDS("../Output/Phyloseq/ps_complete_new_metadata_RFpreds.rds")

# Filter for CP only 
ps_cp_only_np <- ps %>%
  subset_samples(niche == "NP" & population == "CP") # 836 samples

# Prune zero sum taxa and apply filter
ps_cp_only_np_filt <- ps_cp_only_np %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 836 * 0.03, abund = 0.01) # 28 ASVs remaining

# Extract the abundance table (ASV table)
otu_matrix_cp_only_np <- as(otu_table(ps_cp_only_np_filt), "matrix")
otu_matrix_cp_only_np <- t(otu_matrix_cp_only_np)
# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads. 

se_cp_only_np_slr <- spiec.easi(otu_matrix_cp_only_np, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# r defines the rank (size) of the low-rank component of the algorithm - i.e. the effects of latent variables, i.e. the algorithm will estimate up to 10 latent variables - larger r means more complex hidden factors
# lambda.min.ratio = 1e-2: Determines the range of regularization strengths (lambda) to test. 1e-2 means the smallest lambda tested will be 1% of the largest lambda. 
# nlambda = 20: Specifies the number of regularization parameters (lambda) to test. A higher number of lambda values results in finer tuning of the network sparsity.
# pulsar.params = list(rep.num = 20): Configures the Pulsar framework, which performs stability selection by resampling the data.

# Prepare for network plot
ig_slr_cp_only_np_df <- create_ig_df(se_cp_only_np_slr, ps_cp_only_np_filt)
ig_slr_cp_only_np_df %>% arrange(-weight)

 # Prepare for igraph
ig_slr_cp_only_np <- prep_ig(se_cp_only_np_slr, ps_cp_only_np_filt, ig_slr_cp_only_np_df)

igraph_cp_only_np <- plot_ig(ig_slr_cp_only_np) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_np
ggsave("../Output/Networks/Filtering/igraph_cp_all_np.svg", igraph_cp_only_np, width = 8, height = 5.5)
```

## CP (all) OP
```{r}
# Data for all
ps <- readRDS("../Output/Phyloseq/ps_complete_new_metadata_RFpreds.rds")

# Filter for CP only 
ps_cp_only_op <- ps %>%
  subset_samples(niche == "OP" & population == "CP") # 978  samples

# Prune zero sum taxa and apply filter
ps_cp_only_op_filt <- ps_cp_only_op %>%  
  prune_taxa(taxa_sums(.) > 0, .) %>%
  pres_abund_filter(pres = 978 * 0.03, abund = 0.02) # 43 ASVs remaining

# Extract the abundance table (ASV table)
otu_matrix_cp_only_op <- as(otu_table(ps_cp_only_op_filt), "matrix")
otu_matrix_cp_only_op <- t(otu_matrix_cp_only_op)

# Spiec-easi 
se_cp_only_op_slr <- spiec.easi(otu_matrix_cp_only_op, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_op_df <- create_ig_df(se_cp_only_op_slr, ps_cp_only_op_filt)
ig_slr_cp_only_op_df %>% arrange(-weight)

 # Prepare for igraph
ig_slr_cp_only_op <- prep_ig(se_cp_only_op_slr, ps_cp_only_op_filt, ig_slr_cp_only_op_df)

igraph_cp_only_op <- plot_ig(ig_slr_cp_only_op) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right"  # Keeps legend position on the right
  )

igraph_cp_only_op
ggsave("../Output/Networks/Filtering/igraph_cp_all_op.svg", igraph_cp_only_op, width = 8, height = 5.5)
```

### Comparison NP vs OP 
```{r}
# COmpare:
## Degree distribution
## Clustering coefficient
## Average path length
## Network density

# For NP network (igraph_cp_np)
degree_np <- degree(ig_slr_cp_np)
clustering_np <- transitivity(ig_slr_cp_np)
avg_path_length_np <- average.path.length(ig_slr_cp_np)
network_density_np <- edge_density(ig_slr_cp_np)

# For OP network (igraph_cp_op)
degree_op <- degree(ig_slr_cp_op)
clustering_op <- transitivity(ig_slr_cp_op)
avg_path_length_op <- average.path.length(ig_slr_cp_op)
network_density_op <- edge_density(ig_slr_cp_op)

# Compare the networks
comparison_cp_npvsop <- data.frame(
  Metric = c("Average Degree", "Clustering Coefficient", "Avg Path Length", "Density"),
  NP = c(mean(degree_np), mean(clustering_np), avg_path_length_np, network_density_np),
  OP = c(mean(degree_op), mean(clustering_op), avg_path_length_op, network_density_op)
)

print(comparison_cp_npvsop)


##### Compare community structure
# Using Louvain community detection
community_np <- cluster_louvain(ig_slr_cp_np)
community_op <- cluster_louvain(ig_slr_cp_op)

# Get the modularity score to assess how well the network is divided into communities
modularity_np <- modularity(community_np)
modularity_op <- modularity(community_op)

# Compare the modularity
print(modularity_np)
print(modularity_op)
```

# Filtering of data based on power law
## Farmers vs residents
### NP 
```{r}
# Now I try filtering taxa based on their degree in the network
# Such filtering focuses on the importance of nodes in the network rather than their abundance or prevalence in the original dataset.
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for NP only 
ps_cp_gf_np <- ps_cp_gf %>%
  subset_samples(niche == "NP") # 237 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_np <- ps_cp_gf_np %>%  
  prune_taxa(taxa_sums(.) > 0, .) 

# Extract the abundance table (ASV table)
asv_matrix_cp_gf_np <- as(otu_table(ps_cp_gf_np), "matrix")
asv_matrix_cp_gf_np <- t(asv_matrix_cp_gf_np)

# Sum each column of the ASV matrix i.e. sum the abundance of each ASV across all samples 
column_sums <- colSums(asv_matrix_cp_gf_np) 

# Create a new dataframe with the column names as row names and the sums as values
sum_df <- data.frame(
  ASV = names(column_sums),
  Sum = column_sums
)
rownames(sum_df) <- NULL

# Sort the sums in descending order -i.e. most abundant first
sum_df_sorted <- sum_df[order(-sum_df$Sum), ]

# Log-transform the sums 
sum_df_sorted <- sum_df_sorted %>%
  mutate(log_sum = log10(Sum + 1))  # Log-transform

# Check the distribution of all ASV sums
line_plot_sums <- ggplot(sum_df_sorted, aes(x = seq_along(Sum), y = Sum)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Distribution of Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )
# Looks like a power law distribution

# Log sums plot
line_plot_log <- ggplot(sum_df_sorted, aes(x = seq_along(log_sum), y = log_sum)) +  # Use index for x-axis
  geom_line() +
  theme_minimal() +  # Clean theme
  labs(
    title = "Distribution of log Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum (log)"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )

# Fit the power-law model to the log_sum values and estimate the xmin threshold
power_law_model <- conpl$new(sum_df_sorted$log_sum)  # Initialize power-law model on log_sum
xmin_estimation <- estimate_xmin(power_law_model)  # Estimate xmin
power_law_model$setXmin(xmin_estimation)  # Set xmin for the model
xmin <- xmin_estimation$xmin  # Extract xmin = 3.21801
ntail <- xmin_estimation$ntail  # Extract the number of points in the tail region (i.e those that follow the power law distribution) = 154

# Select tail data based on the model - i.e. select the "tail" data points: the ASVs whose log-transformed summed abundance is greater than or equal to the estimated xmin threshold.
# These ASVs are considered the most interesting in the network based on their position in the power-law tail (indicating that they have a disproportionate influence or importance).
tail_indices <- which(sum_df_sorted$log_sum >= xmin)  # Find indices for the tail region
tail_data <- sum_df_sorted[tail_indices, ]  # Use indices to subset the data
# Save as data table
tail_ASVs <- data.table(unique(tail_data$ASV))

# Save the tail data
write.csv(tail_data, "../Output/Networks/Power_law/Power_law_ASV_selection.csv", row.names = FALSE)

# Save key results into a table
pl_results <- data.frame(
  xmin = xmin,
  pars = power_law_model$pars,  # Power-law parameters
  ntail = ntail,
  distance = xmin_estimation$distance,  # Distance metric
  gof = xmin_estimation$gof  # Goodness of fit
)
write.csv(pl_results, "../Output/Networks/Power_law/Power_law_model_results.csv", row.names = FALSE)


# Subset the original phyloseq object (ps_cp_gf_np) to retain only the 154 ASVs identified in the
# Load the tail ASVs (from the previous code) into a vector
tail_ASVs_vector <- tail_ASVs$V1  # Extract ASV names (assuming 'V1' is the column containing the ASV names)

# Subset the phyloseq object to retain only the selected ASVs
ps_cp_gf_np_plsubset <- prune_taxa(taxa_names(ps_cp_gf_np) %in% tail_ASVs_vector, ps_cp_gf_np)
ps_cp_gf_np_plsubset # Now only 154 taxa 


#### GF ####
# Subset phyloseq for GF
ps_gf_only_np_plsubset <- ps_cp_gf_np_plsubset %>%
  subset_samples(population == "GF") # 77 samples, 154 taxa
# Prune zero sum taxa
ps_gf_only_np_plsubset <- ps_gf_only_np_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 128 taxa remaining
# Extract the abundance table (ASV table)
asv_matrix_gf_only_np_plsubset <- as(otu_table(ps_gf_only_np_plsubset), "matrix")
asv_matrix_gf_only_np_plsubset <- t(asv_matrix_gf_only_np_plsubset)
# Run spiec-easi
se_gf_only_np_slr_plsubset <- spiec.easi(asv_matrix_gf_only_np_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_gf_only_np_df_plsubset <- create_ig_df(se_gf_only_np_slr_plsubset, ps_gf_only_np_plsubset)
ig_slr_gf_only_np_df_plsubset %>% arrange(-weight)
# Prepare for igraph
ig_slr_gf_only_np_plsubset <- prep_ig(se_gf_only_np_slr_plsubset, ps_gf_only_np_plsubset, ig_slr_gf_only_np_df_plsubset)


# To make sure the node colours are the same in the gf and cp population networks
# Get unique Orders from both datasets
all_orders_np <- unique(c(V(ig_slr_gf_only_np_plsubset)$Order, V(ig_slr_cp_only_np_plsubset)$Order))
# Generate a consistent color palette
order_colors_np <- colorRampPalette(brewer.pal(9, "Set3"))(length(all_orders_np))
names(order_colors_np) <- all_orders_np


# Network with all ASVs labelled 
gf_np_network_all_labels <- plot_ig_nodal_size(ig_slr_gf_only_np_plsubset) +
  scale_colour_manual(values = order_colors_np) +  # Apply consistent colors
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/GF_NP_network_all_labels.svg", gf_np_network_all_labels, width = 8, height = 5.5)

# Network with specified ASV labels 
# Specify ASVs of interest (significant in MaAsLin analysis)
selected_asvs_np <- c(
  "Staphylococcus_256", "Staphylococcaceae_295", "Sphingomonas_175", 
  "Corynebacterium_stationis_251"
)

# Generate the plots
igraph_gf_np_selected_labels <- plot_ig_nodal_size_selected_labels(ig_slr_gf_only_np_plsubset, selected_asvs_np) + 
  scale_colour_manual(values = order_colors_np) +  # Apply consistent colors
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/GF_NP_network_selected_labels.svg", igraph_gf_np_selected_labels, width = 8, height = 5.5)


#### CP ####
# Subset phyloseq for CP
ps_cp_only_np_plsubset <- ps_cp_gf_np_plsubset %>%
  subset_samples(population == "CP") # 160 samples, 154 taxa
# Prune zero sum taxa
ps_cp_only_np_plsubset <- ps_cp_only_np_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 139 taxa remaining
# Extract the abundance table (ASV table)
asv_matrix_cp_only_np_plsubset <- as(otu_table(ps_cp_only_np_plsubset), "matrix")
asv_matrix_cp_only_np_plsubset <- t(asv_matrix_cp_only_np_plsubset)

# Run spiec-easi
se_cp_only_np_slr_plsubset <- spiec.easi(asv_matrix_cp_only_np_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))

# Prepare for network plot
ig_slr_cp_only_np_df_plsubset <- create_ig_df(se_cp_only_np_slr_plsubset, ps_cp_only_np_plsubset)
ig_slr_cp_only_np_df_plsubset %>% arrange(-weight)
# Prepare for igraph
ig_slr_cp_only_np_plsubset <- prep_ig(se_cp_only_np_slr_plsubset, ps_cp_only_np_plsubset, ig_slr_cp_only_np_df_plsubset)

# Network with all ASVs labelled 
cp_np_network_all_labels <- plot_ig_nodal_size(ig_slr_cp_only_np_plsubset) +
  scale_colour_manual(values = order_colors_np) +  # Apply consistent colors
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/CP_NP_network_all_labels.svg", cp_np_network_all_labels, width = 8, height = 5.5)

# Network with specified ASV labels 
# Specify ASVs of interest (significant in MaAsLin analysis)
selected_asvs_np <- c(
  "Staphylococcus_256", "Staphylococcaceae_295", "Sphingomonas_175", 
  "Corynebacterium_stationis_251"
)

# Generate the plots
igraph_cp_np_selected_labels <- plot_ig_nodal_size_selected_labels(ig_slr_cp_only_np_plsubset, selected_asvs_np) + 
  scale_colour_manual(values = order_colors_np) +  # Apply consistent colors
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/CP_NP_network_selected_labels.svg", igraph_cp_np_selected_labels, width = 8, height = 5.5)
```
#### Comparison metrics (to continue)
```{r}
# Compare nodes and overall network

# Nodes alone 
## Degree
## Betweeness centrality

# Network overall 
## Network Density - Proportion of potential connections in the network that are actual connections
## Modularity - Quantifies the strength of division of a network into modules
## Clustering coefficient - Measures how much nodes tend to cluster together


# Calculate degree for all nodes in the Goat Farmers network
degree_gf_np <- degree(ig_slr_gf_only_np_plsubset)

# Find the ASV with the highest degree (index of the maximum degree)
max_degree_gf_index_np <- which.max(degree_gf_np)
max_degree_gf_value_np <- degree_gf_np[max_degree_gf_index_np]
asv_names_np <- V(ig_slr_gf_only_np_plsubset)$ASV  
max_degree_asv_gf_np <- asv_names_np[max_degree_gf_index_np]
cat("Goat Farmer network: ASV with the highest degree is", max_degree_asv_gf_np, "with degree", max_degree_gf_value_np, "\n") 
# Goat Farmer network: ASV with the highest degree is Moraxella_5 with degree 6 

# Residents network - NP 
degree_cp_np <- degree(ig_slr_cp_only_np_plsubset)
max_degree_cp_index_np <- which.max(degree_cp_np)
max_degree_cp_value_np <- degree_cp_np[max_degree_cp_index_np]
asv_names_cp_np <- V(ig_slr_cp_only_np_plsubset)$ASV
max_degree_asv_cp_np <- asv_names_cp_np[max_degree_cp_index_np]

cat("Control network: ASV with the highest degree is", max_degree_asv_cp_np, "with degree", max_degree_cp_value_np, "\n") 
# Control network: ASV with the highest degree is Dolosigranulum_pigrum_1 with degree 4 

# Calculate betweenness centrality for Goat Farmers network
betweenness_gf_np <- betweenness(ig_slr_gf_only_np_plsubset, normalized = TRUE)
max_betweenness_gf_index_np <- which.max(betweenness_gf_np)
max_betweenness_gf_value_np <- betweenness_gf_np[max_betweenness_gf_index_np]
asv_names_np <- V(ig_slr_gf_only_np_plsubset)$ASV
max_betweenness_asv_gf_np <- asv_names_np[max_betweenness_gf_index_np]
cat("Goat Farmer network: ASV with the highest betweenness centrality is", 
    max_betweenness_asv_gf_np, "with betweenness", max_betweenness_gf_value_np, "\n")
# Goat Farmer network: ASV with the highest betweenness centrality is Moraxella_5 with (normalised) betweenness 0.01162355  

# Calculate betweenness centrality for Control Population network
betweenness_cp_np <- betweenness(ig_slr_cp_only_np_plsubset, normalized = TRUE)
max_betweenness_cp_index_np <- which.max(betweenness_cp_np)
max_betweenness_cp_value_np <- betweenness_cp_np[max_betweenness_cp_index_np]
asv_names_cp_np <- V(ig_slr_cp_only_np_plsubset)$ASV
max_betweenness_asv_cp_np <- asv_names_cp_np[max_betweenness_cp_index_np]
cat("Control network: ASV with the highest betweenness centrality is", 
    max_betweenness_asv_cp_np, "with betweenness", max_betweenness_cp_value_np, "\n")
# Control network: ASV with the highest betweenness centrality is Staphylococcus_2 with (normalised) betweenness 0.003067809  


# Overall network metrics
# Network Density
density_gf_np <- edge_density(ig_slr_gf_only_np_plsubset) # 0.003198819
# Clustering Coefficient
clustering_coef_gf_np <- transitivity(ig_slr_gf_only_np_plsubset, type = "average") # 0.4277778
# Modularity
# Using the Louvain method to define communities 
communities_gf_np <- cluster_louvain(ig_slr_gf_only_np_plsubset)
modularity_gf_np <- modularity(ig_slr_gf_only_np_plsubset, membership(communities_gf_np))

# Repeat for Control Population (CP) network
density_cp_np <- edge_density(ig_slr_cp_only_np_plsubset)
clustering_coef_cp_np <- transitivity(ig_slr_cp_only_np_plsubset, type = "average")
communities_cp_np <- cluster_louvain(ig_slr_cp_only_np_plsubset)
modularity_cp_np <- modularity(ig_slr_cp_only_np_plsubset, membership(communities_cp_np))

# Print results
cat("Goat Farmers Network:\n")
cat("Density:", density_gf, "\n")
cat("Average Clustering Coefficient:", clustering_coef_gf, "\n")
cat("Modularity:", modularity_gf, "\n\n")

cat("Control Population Network:\n")
cat("Density:", density_cp, "\n")
cat("Average Clustering Coefficient:", clustering_coef_cp, "\n")
cat("Modularity:", modularity_cp, "\n")

# Create a data frame with network metrics
network_metrics_np <- data.frame(
  Network = c("Goat Farmers", "Control Population"),
  Density = c(density_gf_np, density_cp_np),
  `Clustering Coefficient` = c(clustering_coef_gf_np, clustering_coef_cp_np),
  Modularity = c(modularity_gf_np, modularity_cp_np)
)

print(network_metrics_np)
# Save as Excel file
write_xlsx(network_metrics_np, "../Output/Networks/Power_law/network_comparison_metrics_np.xlsx")



```


### OP 
```{r}
# Now I try filtering taxa based on their degree in the network
# Such filtering focuses on the importance of nodes in the network rather than their abundance or prevalence in the original dataset.
# Data for all
ps_cp_gf <- readRDS("../Output/Phyloseq/ps_complete_matchedCPGF.rds")

# Filter for op only 
ps_cp_gf_op <- ps_cp_gf %>%
  subset_samples(niche == "OP") # 287 samples

# Prune zero sum taxa and apply filter
ps_cp_gf_op <- ps_cp_gf_op %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 3411 taxa

# Add an extra filter as there are too many taxa in the OP after applying power law cut off
# Calculate prevalence for each ASV
prevalence <- apply(otu_table(ps_cp_gf_op), 1, function(x) sum(x > 0) / nsamples(ps_cp_gf_op))
# Filter taxa based on prevalence (e.g., keep taxa present in at least 10% of samples)
prevalence_threshold <- 0.1
taxa_to_keep <- names(prevalence[prevalence >= prevalence_threshold])
# Prune the phyloseq object to retain only the selected taxa
ps_cp_gf_op_filt <- prune_taxa(taxa_to_keep, ps_cp_gf_op) # 243 taxa, 287 samples


# Extract the abundance table (ASV table)
asv_matrix_cp_gf_op <- as(otu_table(ps_cp_gf_op_filt), "matrix")
asv_matrix_cp_gf_op <- t(asv_matrix_cp_gf_op)

# Sum each column of the ASV matrix i.e. sum the abundance of each ASV across all samples 
column_sums_op <- colSums(asv_matrix_cp_gf_op) 

# Create a new dataframe with the column names as row names and the sums as values
sum_df_op <- data.frame(
  ASV = names(column_sums_op),
  Sum = column_sums_op
)
rownames(sum_df_op) <- NULL

# Sort the sums in descending order -i.e. most abundant first
sum_df_op_sorted <- sum_df_op[order(-sum_df_op$Sum), ]

# Log-transform the sums 
sum_df_op_sorted <- sum_df_op_sorted %>%
  mutate(log_sum = log10(Sum + 1))  # Log-transform

# Check the distribution of all ASV sums
line_plot_sums_op <- ggplot(sum_df_op_sorted, aes(x = seq_along(Sum), y = Sum)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Distribution of Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )
# Looks like a power law distribution

# Log sums plot
line_plot_log_op <- ggplot(sum_df_op_sorted, aes(x = seq_along(log_sum), y = log_sum)) +  # Use index for x-axis
  geom_line() +
  theme_minimal() +  # Clean theme
  labs(
    title = "Distribution of log Sum Values Across ASVs (High to Low Abundance)",
    x = "ASV",
    y = "Sum (log)"
  ) +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    plot.title = element_text(hjust = 0.5)  # Center the title
  )

# # Fit the power-law model to the log_sum values and estimate the xmin threshold
power_law_model_op <- conpl$new(sum_df_op_sorted$log_sum)  # Initialize power-law model on log_sum
xmin_estimation_op <- estimate_xmin(power_law_model_op)  # Estimate xmin
power_law_model_op$setXmin(xmin_estimation_op)  # Set xmin for the model
xmin_op <- xmin_estimation_op$xmin  # Extract xmin = 3.915294
ntail_op <- xmin_estimation_op$ntail  # Extract the number of points in the tail region (i.e those that follow the power law distribution) = 96

# Select tail data based on the model - i.e. select the "tail" data points: the ASVs whose log-transformed summed abundance is greater than or equal to the estimated xmin threshold.
# These ASVs are considered the most interesting in the network based on their position in the power-law tail (indicating that they have a disproportionate influence or importance).
tail_indices_op <- which(sum_df_op_sorted$log_sum >= xmin_op)  # Find indices for the tail region
tail_data_op <- sum_df_op_sorted[tail_indices_op, ]  # Use indices to subset the data
# Save as data table
tail_ASVs_op <- data.table(unique(tail_data_op$ASV))

# Save the tail data
write.csv(tail_data_op, "../Output/Networks/Power_law/Power_law_ASV_selection_op.csv", row.names = FALSE)

# Save key results into a table
pl_results_op <- data.frame(
  xmin = xmin_op,
  pars = power_law_model_op$pars,  # Power-law parameters
  ntail = ntail_op,
  distance = xmin_estimation_op$distance,  # Distance metric
  gof = xmin_estimation_op$gof  # Goodness of fit
)
write.csv(pl_results_op, "../Output/Networks/Power_law/Power_law_model_results_op.csv", row.names = FALSE)


# Subset the original phyloseq object (ps_cp_gf_np) to retain only the 154 ASVs identified in the
# Load the tail ASVs (from the previous code) into a vector
tail_ASVs_vector_op <- tail_ASVs_op$V1  # Extract ASV names (assuming 'V1' is the column containing the ASV names)

# Subset the phyloseq object to retain only the selected ASVs
ps_cp_gf_op_plsubset <- prune_taxa(taxa_names(ps_cp_gf_op_filt) %in% tail_ASVs_vector_op, ps_cp_gf_op_filt)
ps_cp_gf_op_plsubset # Now only 96 taxa 


#### GF ####
# Subset phyloseq for GF
ps_gf_only_op_plsubset <- ps_cp_gf_op_plsubset %>%
  subset_samples(population == "GF") # 92 samples, 96 taxa

# Prune zero sum taxa
ps_gf_only_op_plsubset <- ps_gf_only_op_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # 94 taxa remaining

# Extract the abundance table (ASV table)
asv_matrix_gf_only_op_plsubset <- as(otu_table(ps_gf_only_op_plsubset), "matrix")
asv_matrix_gf_only_op_plsubset <- t(asv_matrix_gf_only_op_plsubset)

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_gf_only_op_slr_plsubset <- spiec.easi(asv_matrix_gf_only_op_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))


# Prepare for network plot
ig_slr_gf_only_op_df_plsubset <- create_ig_df(se_gf_only_op_slr_plsubset, ps_gf_only_op_plsubset)
ig_slr_gf_only_op_df_plsubset %>% arrange(-weight)

# Prepare for igraph
ig_slr_gf_only_op_plsubset <- prep_ig(se_gf_only_op_slr_plsubset, ps_gf_only_op_plsubset, ig_slr_gf_only_op_df_plsubset)

# To make sure the node colours are the same in the gf and cp population networks
# Get unique Orders from both datasets
all_orders <- unique(c(V(ig_slr_gf_only_op_plsubset)$Order, V(ig_slr_cp_only_op_plsubset)$Order))
# Generate a consistent color palette
order_colors <- colorRampPalette(brewer.pal(9, "Set3"))(length(all_orders))
names(order_colors) <- all_orders

# Network with all ASVs labelled 
gf_op_network_all_labels <- plot_ig_nodal_size(ig_slr_gf_only_op_plsubset) +
  scale_colour_manual(values = order_colors) +  # Apply consistent colors
  theme_minimal() + 
  theme(
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    axis.title = element_blank(),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.spacing = unit(0.5, "lines"),
    legend.key.size = unit(0.5, "lines"),
    legend.position = "right",
    panel.grid = element_blank()
  )

# Save the GF plot
ggsave("../Output/Networks/Power_law/GF_OP_network_all_labels.svg", gf_op_network_all_labels, width = 9, height = 7)

gf_op_network_all_labels <- plot_ig_nodal_size(ig_slr_gf_only_op_plsubset) +
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/GF_OP_network_all_labels.svg", gf_op_network_all_labels, width = 9, height = 7)

# Plot the network with degree-based node sizing and selected labels
selected_asvs_op <- c(
  "Veillonella_62", "Veillonella_6", "Streptococcus_8", 
  "Streptococcus_4", "Streptococcus_10", "Prevotella_salivae_29", 
  "Prevotella_histicola_12", "Prevotella_16", "Prevotella_109", 
  "Actinomyces_graevenitzii_22"
)

# Generate the plots
igraph_gf_op_selected_labels <- plot_ig_nodal_size_selected_labels(ig_slr_gf_only_op_plsubset, selected_asvs_op) +
  scale_colour_manual(values = order_colors) +  # Apply consistent colors 
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/GF_OP_network_selected_labels.svg", igraph_gf_op_selected_labels, width = 8, height = 5.5)

#### CP ####
# Subset phyloseq for CP
ps_cp_only_op_plsubset <- ps_cp_gf_op_plsubset %>%
  subset_samples(population == "CP") # 195 samples, 96 taxa

# Prune zero sum taxa
ps_cp_only_op_plsubset <- ps_cp_only_op_plsubset %>%  
  prune_taxa(taxa_sums(.) > 0, .) # all (96) taxa remaining

# Extract the abundance table (ASV table)
asv_matrix_cp_only_op_plsubset <- as(otu_table(ps_cp_only_op_plsubset), "matrix")
asv_matrix_cp_only_op_plsubset <- t(asv_matrix_cp_only_op_plsubset)

saveRDS(asv_matrix_cp_only_op_plsubset, "../Output/Networks/Power_law/asv_matrix_cp_only_op_plsubset.rds")

# No need to convert phyloseq ASV abundances to relative abundances before running SPIEC-EASI as it is designed to handle compositionality by applying the CLR transformation and is designed to handle raw reads
se_cp_only_op_slr_plsubset <- spiec.easi(asv_matrix_cp_only_op_plsubset, 
                           method ='slr', 
                           r = 5, 
                           lambda.min.ratio = 1e-1,
                           nlambda = 30, 
                           pulsar.params=list(rep.num = 50))


# Prepare for network plot
ig_slr_cp_only_op_df_plsubset <- create_ig_df(se_cp_only_op_slr_plsubset, ps_cp_only_op_plsubset)
ig_slr_cp_only_op_df_plsubset %>% arrange(-weight)
# Prepare for igraph
ig_slr_cp_only_op_plsubset <- prep_ig(se_cp_only_op_slr_plsubset, ps_cp_only_op_plsubset, ig_slr_cp_only_op_df_plsubset)

# Network with all ASVs labelled 
cp_op_network_all_labels <- plot_ig_nodal_size(ig_slr_cp_only_op_plsubset) +
  scale_colour_manual(values = order_colors) +  # Apply consistent colors
  theme_minimal() + 
  theme(
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    axis.title = element_blank(),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.spacing = unit(0.5, "lines"),
    legend.key.size = unit(0.5, "lines"),
    legend.position = "right",
    panel.grid = element_blank()
  )

# Save the CP plot
ggsave("../Output/Networks/Power_law/CP_OP_network_all_labels.svg", cp_op_network_all_labels, width = 9, height = 7)


# Plot the network with degree-based node sizing and selected labels
selected_asvs_op <- c(
  "Veillonella_62", "Veillonella_6", "Streptococcus_8", 
  "Streptococcus_4", "Streptococcus_10", "Prevotella_salivae_29", 
  "Prevotella_histicola_12", "Prevotella_16", "Prevotella_109", 
  "Actinomyces_graevenitzii_22"
)

# Generate the plots
igraph_cp_op_selected_labels <- plot_ig_nodal_size_selected_labels(ig_slr_cp_only_op_plsubset, selected_asvs_op) +
  scale_colour_manual(values = order_colors) +  # Apply consistent colors 
  theme_minimal() + # Use a clean theme
  theme(
    panel.background = element_rect(fill = "white", color = NA), # White panel background
    plot.background = element_rect(fill = "white", color = NA),  # White plot background
    axis.line = element_blank(),      # Removes x and y axis lines
    axis.ticks = element_blank(),     # Removes axis ticks
    axis.text = element_blank(),      # Removes axis text
    axis.title = element_blank(),     # Removes axis titles
    legend.text = element_text(size = 10), # Adjusts size of legend text
    legend.title = element_text(size = 10), # Adjusts size of legend title
    legend.spacing = unit(0.5, "lines"),  # Reduces spacing between legend items
    legend.key.size = unit(0.5, "lines"), # Makes legend keys smaller
    legend.position = "right",  # Keeps legend position on the right
    panel.grid = element_blank(),  # Remove all grid lines (guidelines)

  )

# Save the plot
ggsave("../Output/Networks/Power_law/CP_OP_network_selected_labels.svg", igraph_cp_op_selected_labels, width = 8, height = 5.5)


```
#### Compariton metrics
```{r}
# Compare nodes and overall network

# Nodes alone 
## Degree
## Betweeness centrality

# Network overall 
## Network Density - Proportion of potential connections in the network that are actual connections
## Modularity - Quantifies the strength of division of a network into modules
## Clustering coefficient - Measures how much nodes tend to cluster together


# Calculate degree for all nodes in the Goat Farmers network
degree_gf_op <- degree(ig_slr_gf_only_op_plsubset)

# Find the ASV with the highest degree (index of the maximum degree)
max_degree_gf_index_op <- which.max(degree_gf_op)
max_degree_gf_value_op <- degree_gf_op[max_degree_gf_index_op]
asv_names_op <- V(ig_slr_gf_only_op_plsubset)$ASV  
max_degree_asv_gf_op <- asv_names_op[max_degree_gf_index_op]
cat("Goat Farmer network: ASV with the highest degree is", max_degree_asv_gf_op, "with degree", max_degree_gf_value_op, "\n") 
# Goat Farmer network: ASV with the highest degree is Moraxella_5 with degree 6 

# Residents network - op 
degree_cp_op <- degree(ig_slr_cp_only_op_plsubset)
max_degree_cp_index_op <- which.max(degree_cp_op)
max_degree_cp_value_op <- degree_cp_op[max_degree_cp_index_op]
asv_names_cp_op <- V(ig_slr_cp_only_op_plsubset)$ASV
max_degree_asv_cp_op <- asv_names_cp_op[max_degree_cp_index_op]

cat("Control network: ASV with the highest degree is", max_degree_asv_cp_op, "with degree", max_degree_cp_value_op, "\n") 
# Control network: ASV with the highest degree is Dolosigranulum_pigrum_1 with degree 4 

# Calculate betweenness centrality for Goat Farmers network
betweenness_gf_op <- betweenness(ig_slr_gf_only_op_plsubset, normalized = TRUE)
max_betweenness_gf_index_op <- which.max(betweenness_gf_op)
max_betweenness_gf_value_op <- betweenness_gf_op[max_betweenness_gf_index_op]
asv_names_op <- V(ig_slr_gf_only_op_plsubset)$ASV
max_betweenness_asv_gf_op <- asv_names_op[max_betweenness_gf_index_op]
cat("Goat Farmer network: ASV with the highest betweenness centrality is", 
    max_betweenness_asv_gf_op, "with betweenness", max_betweenness_gf_value_op, "\n")
# Goat Farmer network: ASV with the highest betweenness centrality is Moraxella_5 with (normalised) betweenness 0.01162355  

# Calculate betweenness centrality for Control Population network
betweenness_cp_op <- betweenness(ig_slr_cp_only_op_plsubset, normalized = TRUE)
max_betweenness_cp_index_op <- which.max(betweenness_cp_op)
max_betweenness_cp_value_op <- betweenness_cp_op[max_betweenness_cp_index_op]
asv_names_cp_op <- V(ig_slr_cp_only_op_plsubset)$ASV
max_betweenness_asv_cp_op <- asv_names_cp_op[max_betweenness_cp_index_op]
cat("Control network: ASV with the highest betweenness centrality is", 
    max_betweenness_asv_cp_op, "with betweenness", max_betweenness_cp_value_op, "\n")
# Control network: ASV with the highest betweenness centrality is Staphylococcus_2 with (normalised) betweenness 0.003067809  


# Overall network metrics
# Network Density
density_gf_op <- edge_density(ig_slr_gf_only_op_plsubset) # 0.003198819
# Clustering Coefficient
clustering_coef_gf_op <- transitivity(ig_slr_gf_only_op_plsubset, type = "average") # 0.4277778
# Modularity
# Using the Louvain method to define communities 
communities_gf_op <- cluster_louvain(ig_slr_gf_only_op_plsubset)
modularity_gf_op <- modularity(ig_slr_gf_only_op_plsubset, membership(communities_gf_op))

# Repeat for Control Population (CP) network
density_cp_op <- edge_density(ig_slr_cp_only_op_plsubset)
clustering_coef_cp_op <- transitivity(ig_slr_cp_only_op_plsubset, type = "average")
communities_cp_op <- cluster_louvain(ig_slr_cp_only_op_plsubset)
modularity_cp_op <- modularity(ig_slr_cp_only_op_plsubset, membership(communities_cp_op))

# Create a data frame with network metrics
network_metrics_op <- data.frame(
  Network = c("Goat Farmers", "Control Population"),
  Density = c(density_gf_op, density_cp_op),
  `Clustering Coefficient` = c(clustering_coef_gf_op, clustering_coef_cp_op),
  Modularity = c(modularity_gf_op, modularity_cp_op)
)

print(network_metrics_op)
# Save as Excel file
write_xlsx(network_metrics_op, "../Output/Networks/Power_law/network_comparison_metrics_op.xlsx")

```

## Patchwork figures
```{r}
# ASV level
# NP 
combined_plot_np <- igraph_gf_only_np + igraph_cp_only_np + plot_layout(ncol = 2)
print(combined_plot_np)
ggsave("../Output/Networks/Filtering/combined_network_NP.svg", combined_plot_np, width = 16, height = 5.5)

# OP 
combined_plot_op <- igraph_gf_only_op + igraph_cp_only_op + plot_layout(ncol = 2)
print(combined_plot_op)
ggsave("../Output/Networks/Filtering/combined_network_OP.svg", combined_plot_op, width = 16, height = 5.5)


# Patchwork figures of power law networks
# NP 
# All labels 
network_combined_np_all_labels <- (gf_np_network_all_labels + 
  ggtitle('Goat farmers (NP niche)')) + (cp_np_network_all_labels+ 
  ggtitle('Residents (NP niche)')) + plot_layout(ncol = 2) + plot_annotation(tag_levels = 'A')
print(network_combined_np_all_labels)
ggsave("../Output/Networks/Power_law/NP_networks_all_labels.svg", network_combined_np_all_labels, width = 16, height = 5.5)

# Selected labels
network_combined_np <- (igraph_gf_np_selected_labels + 
  ggtitle('Goat farmers (NP niche)')) + (igraph_cp_np_selected_labels + 
  ggtitle('Residents (NP niche)')) + plot_layout(ncol = 2) + plot_annotation(tag_levels = 'A')
print(network_combined_np)
ggsave("../Output/Networks/Power_law/NP_networks_selected_labels.svg", network_combined_np, width = 16, height = 5.5)


# OP 
network_combined_op_all_labels <- (gf_op_network_all_labels + 
  ggtitle('Goat farmers (OP niche)')) + (cp_op_network_all_labels + 
  ggtitle('Residents (OP niche)')) + plot_layout(ncol = 2)+ plot_annotation(tag_levels = 'A')
print(network_combined_op_all_labels)
ggsave("../Output/Networks/Power_law/OP_networks_all_labels.svg", network_combined_op_all_labels, width = 16, height = 5.5)

# Selected labels
combined_plot_op <- (igraph_gf_op_selected_labels + 
  ggtitle('Goat farmers (OP niche)')) + (igraph_cp_op_selected_labels + 
  ggtitle('Residents (OP niche)')) + plot_layout(ncol = 2)+ plot_annotation(tag_levels = 'A')
print(combined_plot_op)
ggsave("../Output/Networks/Power_law/OP_networks_selected_labels.svg", combined_plot_op, width = 16, height = 5.5)


V(ig_slr_cp_only_np_plsubset)$ASV
all_orders_np <- unique(c(V(ig_slr_gf_only_np_plsubset)$Order, V(ig_slr_cp_only_np_plsubset)$Order))

```

